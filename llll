import rclpy
from rclpy.node import Node
from visualization_msgs.msg import Marker, MarkerArray
from std_msgs.msg import Header
from sensor_msgs.msg import LaserScan
from my_package.msg import Yolov8Inference
from geometry_msgs.msg import PointStamped, PoseStamped, Twist, Point
from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult
import math
import numpy as np
from rclpy.duration import Duration
import tf2_ros
from tf2_geometry_msgs.tf2_geometry_msgs import do_transform_point
from tf_transformations import euler_from_quaternion, quaternion_from_euler
import time
import cv2
from cv_bridge import CvBridge
from sensor_msgs.msg import Image

import base64
import threading
import socketio
sio = socketio.Client()
from queue import Queue


ip="http://192.168.1.31:5000"
# ip="http://127.0.0.1:5000"
# ws= "ws://127.0.0.1:5000/ws"
ws= "ws://192.168.1.31:5000/ws"

class KalmanFilter:
    def __init__(self):
        self.x = np.zeros((4, 1))  # [x, y, vx, vy]
        self.P = np.eye(4) * 1.0
        self.F = np.array([[1, 0, 1, 0],
                           [0, 1, 0, 1],
                           [0, 0, 1, 0],
                           [0, 0, 0, 1]])
        self.H = np.array([[1, 0, 0, 0],
                           [0, 1, 0, 0]])
        self.R = np.eye(2) * 0.1
        self.Q = np.eye(4) * 0.4
        self.I = np.eye(4)
        self.initialized = False
        self.last_update_time = None

    def predict(self):
        if not self.initialized:
            return 0.0, 0.0, 0.0, 0.0
        self.x = self.F @ self.x
        self.P = self.F @ self.P @ self.F.T + self.Q
        return self.x[0, 0], self.x[1, 0], self.x[2, 0], self.x[3, 0]

    def update(self, z, current_time):
        self.initialized = True
        self.last_update_time = current_time
        y = z - self.H @ self.x
        S = self.H @ self.P @ self.H.T + self.R
        K = self.P @ self.H.T @ np.linalg.inv(S)
        self.x = self.x + K @ y
        self.P = (self.I - K @ self.H) @ self.P

    def reset(self):
        self.x = np.zeros((4, 1))
        self.P = np.eye(4) * 1.0
        self.initialized = False
        self.last_update_time = None

class MarkerPublisher(Node):
    def __init__(self):
        super().__init__('marker_publisher')

        self.publisher = self.create_publisher(MarkerArray, 'visualization_marker_array', 10)
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.create_subscription(Yolov8Inference, '/Yolov8_Inference', self.yolo_callback, 10)
        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)

        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        self.detections = []
        self.last_yolo_detection = None
        self.last_yolo_time = None
        self.scan_data = None
        self.timer = self.create_timer(0.05, self.timer_callback)
        self.active_marker_ids = set()

        self.image_width = 640
        self.camera_fov_deg = 66.13
        self.camera_frame = 'camera_link'

        self.navigator = BasicNavigator()
        self.last_sent_goal = None

        self.kf = KalmanFilter()
        self.rate = self.create_rate(10)

        self.last_odom_time = None
        self.odom_stuck_count = 0
        self.last_yolo_check = None
        self.yolo_silent_count = 0

        self.bridge = CvBridge()  # Để chuyển đổi ROS image message sang OpenCV
        self.cv_image = None  # Khai báo biến lưu trữ hình ảnh
        self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)
        self.cmd_vel_pub = self.create_publisher(Twist, "/cmd_vel", 10)

        self.last_stop_time = None
        self.is_stopping = False
        self.last_sent_time = 0
        self.send_interval = 0.5  # gửi ảnh mỗi 0.5s
        self.lock = threading.Lock()


        try:
            sio.connect(ip)
            self.get_logger().info("✅ Đã kết nối tới WebSocket Server.")
        except Exception as e:
            self.get_logger().warn(f"❌ Không kết nối được đến WebSocket server: {e}")

    def image_callback(self, msg):
        try:
            self.cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding="bgr8")
        except Exception as e:
            self.get_logger().warn(f"Lỗi khi chuyển đổi ảnh: {e}")
            self.cv_image = None


    def navigation_through_goal(self):
        if self.is_stopping:
            # Đang trong trạng thái dừng tạm thời → không gửi goal mới
            return

        if not hasattr(self, 'waypoints'):
            self.waypoints = [
                (-8.2,0.0,0.0),
                (-7.5, -3.7, 0),
                (4.73,-3.3,-1.571),
                (22.1542, -4, 1.5648),
                (25.9873, 3.5, 3.06822),
                (15,3.76,1.59446),
                (0.1242,4.1605,-3.13)
            ]
            self.auto_nav_index = 0

        if not self.navigator.isTaskComplete():
            return
        else:
            x, y, yaw = self.waypoints[self.auto_nav_index]
            goal = self.build_goal(x, y, yaw)
            self.get_logger().info(f"[Auto Nav] Đang tới waypoint {self.auto_nav_index}: ({x:.2f}, {y:.2f})")
            self.navigator.goToPose(goal)
            self.last_sent_goal = goal

            self.auto_nav_index += 1
            if self.auto_nav_index >= len(self.waypoints):
                self.auto_nav_index = 0

    def send_image_ws(self, image, label, ws_url=ws):
        now = time.time()
        if now - self.last_sent_time < self.send_interval:
            return  # Gửi cách nhau ít nhất 0.5s

        self.last_sent_time = now

        try:
            _, img_encoded = cv2.imencode('.jpg', image, [int(cv2.IMWRITE_JPEG_QUALITY), 40])
            if img_encoded is None:
                self.get_logger().warn("Failed to encode image.")
                return

            img_base64 = "data:image/jpeg;base64," + base64.b64encode(img_encoded.tobytes()).decode('utf-8')
            message = {
                "label": label,
                "image": img_base64
            }
            self.get_logger().info(f"Encoded image size: {len(img_encoded)} bytes")
            sio.emit("upload_image", message)
            sio.sleep(0)  # Nếu vẫn dùng, cần có vòng lặp nền
            self.get_logger().info(f"Sent image {label} via WebSocket.")
        except Exception as e:
            self.get_logger().warn(f"Error sending image via WebSocket: {e}")


    def yolo_callback(self, msg):
        current_time = self.get_clock().now()
        self.last_yolo_check = current_time
        self.yolo_silent_count = 0

        num_objects = len(msg.yolov8_inference)
        self.get_logger().info(f"Nhận {num_objects} object từ YOLO")
        self.detections = []

        detected = False  # Biến xác định xem có đối tượng nào được phát hiện không
        for det in msg.yolov8_inference:
            if det.class_name in ["person", "fire"]:
                center_x = (det.left + det.right) / 2.0
                angle_offset = -((center_x - self.image_width / 2.0) / (self.image_width / 2.0)) * (self.camera_fov_deg / 2.0)
                
                det_data = {
                    "label": det.class_name,
                    "distance": det.distance,
                    "center_x": center_x,
                    "confidence": det.confidence,
                    "top": det.top,
                    "left": det.left,
                    "bottom": det.bottom,
                    "right": det.right
                }
                self.detections.append(det_data)
                self.last_yolo_detection = det_data
                self.last_yolo_time = current_time

                if det.class_name == "fire":
                    self.get_logger().warn(f"Phát hiện {det.class_name.upper()}: khoảng cách {det.distance:.2f}m, center_x {center_x:.2f}, góc {angle_offset:.1f}°")
                else:
                    self.get_logger().info(f"Phát hiện {det.class_name.upper()}: khoảng cách {det.distance:.2f}m, center_x {center_x:.2f}, góc {angle_offset:.1f}°")

                detected = True  # Đánh dấu đã có đối tượng phát hiện

        # Nếu phát hiện đối tượng (person hoặc fire) và confidence đủ cao, gửi ảnh
        if detected:
            # Duyệt qua tất cả các phát hiện
            for det in self.detections:
                # Điều kiện kiểm tra đối tượng 'person' với độ tin cậy > 0.7 hoặc 'fire'
                if (det["label"] == "person" and det["confidence"] > 0.7) or det["label"] == "fire":
                    top, left, bottom, right = int(det["top"]), int(det["left"]), int(det["bottom"]), int(det["right"])

                    # Kiểm tra nếu self.cv_image không phải là None trước khi sử dụng
                    if self.cv_image is not None:
                        h, w, _ = self.cv_image.shape
                        # Đảm bảo các giá trị top, bottom, left, right không vượt quá kích thước ảnh
                        top = max(0, min(top, h))
                        bottom = max(0, min(bottom, h))
                        left = max(0, min(left, w))
                        right = max(0, min(right, w))

                        # Cắt ảnh theo vùng phát hiện
                        self.image_queue = Queue()
                        self.image_queue.put((crop, det["label"]))
                        crop = self.cv_image[top:bottom, left:right]
                        self.send_image_ws(crop, label=det["label"], ws_url=ws)

                        self.get_logger().info(f"Đã gửi ảnh {det['label']} phát hiện.")

                    else:
                        self.get_logger().warn("Không có hình ảnh để cắt.")
                else:
                    self.get_logger().info("Không phát hiện đối tượng 'person' hoặc 'fire' với độ tin cậy đủ cao.")
        else:
            self.get_logger().info("Không phát hiện đối tượng nào.")


    def scan_callback(self, msg):
        self.scan_data = msg

    def get_position_from_yolo(self, detection):
        distance = detection["distance"]
        center_x = detection["center_x"]

        if distance <= 0:
            self.get_logger().warn("Khoảng cách YOLO không hợp lệ")
            return None, None

        angle_offset_rad = - ((center_x - self.image_width / 2.0) / (self.image_width / 2.0)) * math.radians(self.camera_fov_deg / 2.0)
        x = distance * math.cos(angle_offset_rad)
        y = distance * math.sin(angle_offset_rad)

        point_cam = PointStamped()
        point_cam.header.stamp = self.get_clock().now().to_msg()
        point_cam.header.frame_id = self.camera_frame
        point_cam.point.x = x
        point_cam.point.y = y
        point_cam.point.z = 0.0

        try:
            transform = self.tf_buffer.lookup_transform(
                'map', self.camera_frame, rclpy.time.Time(), timeout=Duration(seconds=0.5)
            )
            point_map = do_transform_point(point_cam, transform)
            return point_map.point.x, point_map.point.y
        except Exception as e:
            self.get_logger().warn(f"Không thể transform từ {self.camera_frame} sang map: {e}")
            return None, None

    def get_robot_position(self):
        try:
            transform = self.tf_buffer.lookup_transform(
                'map', 'base_link', rclpy.time.Time(), timeout=Duration(seconds=0.5)
            )
            translation = transform.transform.translation
            self.get_logger().debug(f"Vị trí robot: x={translation.x:.2f}, y={translation.y:.2f}")
            return translation.x, translation.y
        except Exception as e:
            self.get_logger().warn(f"Không thể lấy pose robot từ TF: {e}")
            return None, None

    def get_robot_orientation(self):
        try:
            transform = self.tf_buffer.lookup_transform(
                'map', 'base_link', rclpy.time.Time(), timeout=Duration(seconds=0.5)
            )
            rotation = transform.transform.rotation
            _, _, yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])
            self.get_logger().debug(f"Hướng robot: {math.degrees(yaw):.2f}°")
            self.last_odom_time = self.get_clock().now()
            self.odom_stuck_count = 0
            return yaw
        except Exception as e:
            self.get_logger().warn(f"Không thể lấy hướng robot từ TF: {e}")
            return None

    def normalize_angle(self, angle):
        while angle > math.pi:
            angle -= 2 * math.pi
        while angle < -math.pi:
            angle += 2 * math.pi
        return angle

    def timer_callback(self):
        now = self.get_clock().now()
        current_ids = set()

        person_tracked = None
        high_confidence = False

        if self.detections:
            people_detections = [d for d in self.detections if d.get("label") == "person"]
            if people_detections:
                low_conf_people = [d for d in people_detections if d.get("confidence", 0.0) < 0.7]
                if low_conf_people:
                    person_tracked = min(low_conf_people, key=lambda d: d.get("distance", float("inf")))
                    high_confidence = False
                    world_x, world_y = self.get_position_from_yolo(person_tracked)
                    if world_x is not None and world_y is not None:
                        self.kf.update(np.array([[world_x], [world_y]]), now)
                        self.kf.last_update_time = now
                        self.kf.initialized = True
                else:
                    # Không còn người nào confidence thấp -> tất cả > 0.7
                    high_confidence = True

            for i, det in enumerate(self.detections):
                world_x, world_y = self.get_position_from_yolo(det)
                if world_x is None or world_y is None:
                    continue
                self.publish_marker(i, world_x, world_y, det)
                current_ids.add(i)


        # ========== Xử lý theo trạng thái ==========

        if person_tracked:
            # Có người, confidence < 0.7 → BÁM NGƯỜI
            world_x, world_y = self.get_position_from_yolo(person_tracked)
            robot_pos = self.get_robot_position()
            if world_x is not None and world_y is not None and robot_pos is not None:
                robot_x, robot_y = robot_pos
                dx = world_x - robot_x
                dy = world_y - robot_y
                distance = math.sqrt(dx ** 2 + dy ** 2)

                self.get_logger().info(f"[YOLO] Bám người – khoảng cách: {distance:.2f}m, confidence: {person_tracked.get('confidence', 0):.2f}")
                goal = self.build_goal(world_x, world_y)
                if self.last_sent_goal is None or self._distance(goal, self.last_sent_goal) > 0.1:
                    self.navigator.goToPose(goal)
                    self.last_sent_goal = goal

            self.auto_nav_enabled = False

        elif high_confidence:
        #     # Tất cả người đều confidence > 0.7
            self.auto_nav_enabled = True

        elif self.kf.initialized:
            # YOLO mất người, fallback dùng Kalman
            dt = (now - self.kf.last_update_time).nanoseconds / 1e9
            if dt < 5.0:
                pred_x, pred_y, _, _ = self.kf.predict()
                robot_pos = self.get_robot_position()
                if robot_pos is not None:
                    robot_x, robot_y = robot_pos
                    goal = self.build_goal(pred_x, pred_y)
                    self.get_logger().warn("[YOLO mất] Fallback theo Kalman")
                    if self.last_sent_goal is None or self._distance(goal, self.last_sent_goal) > 0.1:
                        self.navigator.goToPose(goal)
                        self.last_sent_goal = goal

                self.auto_nav_enabled = False
            else:
                self.get_logger().warn("Kalman quá cũ – tiếp tục hành trình.")
                self.auto_nav_enabled = True

        else:
            # Không phát hiện người và không có Kalman → quay lại hành trình
            self.get_logger().info("Không phát hiện người < 0.7 – tiếp tục hành trình.")
            self.auto_nav_enabled = True

        # ========== Gọi hành trình nếu cho phép ==========
        if self.auto_nav_enabled:
            self.navigation_through_goal()


        self.get_logger().debug("Timer callback kết thúc.")
            
    def rotate_toward_angle(self, target_angle, found_person_check_fn=None):
        if not hasattr(self, 'cmd_vel_pub'):
            self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        target_angle = self.normalize_angle(target_angle)
        tolerance = math.radians(5)
        angular_speed = 0.5
        r = self.create_rate(20, self.get_clock())
        max_rotate_duration = 10
        start_time = time.time()
        twist = Twist()
        twist.linear.x = 0.0
        self.get_logger().info(f"Bắt đầu xoay về góc {math.degrees(target_angle):.1f}°")
        yaw_stuck_count = 0
        max_yaw_stuck = 30
        last_yaw = None

        while rclpy.ok():
            if found_person_check_fn and found_person_check_fn():
                self.get_logger().info("YOLO phát hiện lại người – hủy xoay.")
                break
            robot_yaw = self.get_robot_orientation()
            if robot_yaw is None:
                self.get_logger().warn("Không lấy được góc robot khi xoay.")
                r.sleep()
                continue
            if last_yaw is not None and abs(last_yaw - robot_yaw) < 0.01:
                yaw_stuck_count += 1
                self.get_logger().warn(f"Robot không xoay, yaw không đổi ({yaw_stuck_count}/{max_yaw_stuck}).")
                if yaw_stuck_count >= max_yaw_stuck:
                    self.get_logger().error("Yaw kẹt quá lâu – dừng xoay để an toàn.")
                    break
            else:
                yaw_stuck_count = 0
            last_yaw = robot_yaw
            angle_diff = self.normalize_angle(target_angle - robot_yaw)
            self.get_logger().info(f"[Rotate] robot_yaw: {math.degrees(robot_yaw):.1f}°, target: {math.degrees(target_angle):.1f}°, diff: {math.degrees(angle_diff):.1f}°")
            if abs(angle_diff) < tolerance:
                self.get_logger().info("Đạt được góc mục tiêu.")
                break
            twist.angular.z = angular_speed if angle_diff > 0 else -angular_speed
            self.cmd_vel_pub.publish(twist)
            r.sleep()
            if time.time() - start_time > max_rotate_duration:
                self.get_logger().warn("Xoay quá lâu – dừng để tránh kẹt.")
                break
        twist.angular.z = 0.0
        self.cmd_vel_pub.publish(twist)
        self.get_logger().info("Hoàn thành xoay.")

    def publish_marker(self, marker_id, x, y, det):
        marker_array = MarkerArray()

        # --- Marker Text ---
        text_marker = Marker()
        text_marker.header = Header()
        text_marker.header.stamp = self.get_clock().now().to_msg()
        text_marker.header.frame_id = "map"
        text_marker.ns = "detections"
        text_marker.id = marker_id *2
        text_marker.type = Marker.TEXT_VIEW_FACING
        text_marker.action = Marker.ADD
        text_marker.pose.position.x = float(x)
        text_marker.pose.position.y = float(y)
        text_marker.pose.position.z = 0.2
        text_marker.scale.z = 0.2
        text_marker.text = f"{det['label']}:{det['distance']:.2f}m"
        text_marker.color.r = 1.0
        text_marker.color.g = 0.0
        text_marker.color.b = 0.0
        text_marker.color.a = 1.0
        text_marker.lifetime = Duration(seconds=2).to_msg()

        marker_array.markers.append(text_marker)

        # --- Circle Marker ---
        circle_marker = Marker()
        circle_marker.header = text_marker.header
        circle_marker.ns = "detections"
        circle_marker.id = marker_id *2 +1
        circle_marker.type = Marker.LINE_STRIP
        circle_marker.action = Marker.ADD
        circle_marker.pose.orientation.w = 1.0
        circle_marker.scale.x = 0.03
        circle_marker.color.r = 0.0
        circle_marker.color.g = 0.5
        circle_marker.color.b = 1.0
        circle_marker.color.a = 1.0
        circle_marker.lifetime = Duration(seconds=2).to_msg()
        
        radius = 0.6
        num_points = 70
        for i in range(num_points + 1):
            angle = 2 * math.pi * i / num_points
            px = x + radius * math.cos(angle)
            py = y + radius * math.sin(angle)
            p = Point(x=px, y=py, z=0.05)
            circle_marker.points.append(p)

        marker_array.markers.append(circle_marker)

        # --- Publish ---
        self.publisher.publish(marker_array)
        self.active_marker_ids.add(marker_id)

    def build_goal(self, x, y, yaw=None):
        goal = PoseStamped()
        goal.header.frame_id = 'map'
        goal.header.stamp = self.get_clock().now().to_msg()
        goal.pose.position.x = float(x)
        goal.pose.position.y = float(y)
        goal.pose.position.z = 0.0
        if yaw is not None:
            q = quaternion_from_euler(0.0, 0.0, yaw)
            goal.pose.orientation.x = q[0]
            goal.pose.orientation.y = q[1]
            goal.pose.orientation.z = q[2]
            goal.pose.orientation.w = q[3]
        else:
            goal.pose.orientation.w = 1.0
        return goal

    def cleanup_old_markers(self, current_ids):
        for old_id in self.active_marker_ids - current_ids:
            # Xóa cả text_marker và circle_marker
            for marker_id in [old_id * 2, old_id * 2 + 1]:
                delete_marker = MarkerArray()
                delete_marker.header.stamp = self.get_clock().now().to_msg()
                delete_marker.header.frame_id = "map"
                delete_marker.ns = "detections"
                delete_marker.id = marker_id
                delete_marker.action = Marker.DELETE
                delete_marker.lifetime = Duration(seconds=0).to_msg()
                self.publisher.publish(delete_marker)
        
        # Cập nhật active_marker_ids sau khi dọn dẹp
        self.active_marker_ids = current_ids

    def _distance(self, goal1, goal2):
        dx = goal1.pose.position.x - goal2.pose.position.x
        dy = goal1.pose.position.y - goal2.pose.position.y
        return math.sqrt(dx ** 2 + dy ** 2)

def main(args=None):
    rclpy.init(args=args)
    node = MarkerPublisher()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

